import { Sandpack } from '@codesandbox/sandpack-react';
import { BlurFlow, BlurFlowStep, BrowserWindow, unblurNextStep } from '@jaouan/labosaurus';

# 1. La th√©orie des MFE

## Principe

üëâ Le principe de microfront (ou MicroFrontEnd ou MFE) consiste √† charger/d√©charger √† la demande, au sein d'une m√™me application, des √©l√©ments IHM qui ont leur propre cycle de vie.
  
Nous retrouvons g√©n√©ralement plusieurs modules :

- un **shell** : la **coquille vide** qui contient le coeur logique. C'est **le point d'entr√©e**, qui va g√©rer le chargement et l'affichage des √©l√©ments microfront. Il connait, ou du moins sait o√π aller chercher, la liste des √©l√©ments microfronts disponibles.
- un **layout** : la **mise en page** qui donne les indications au shell sur o√π disposer les microfronts √† l'√©cran. Parfois, le layout est int√©gr√© directement dans le shell.
- les **√©l√©ments microfronts** : les contenus/parcours/composants √† afficher.

Il peut y avoir plusieurs sp√©cificit√©s dans l'approche :

- Est-ce qu'il y a **1 ou N composants affich√©s** en m√™me temps sur un √©cran ?
- Est-ce que les composants **partagent des donn√©es** entre eux ?
- Est-ce qu'un composant peut √™tre **int√©gr√© de plusieurs mani√®res** diff√©rentes (en tant que page compl√®te, et en tant que "morceau" d'une autre page) ?
- Quelles sont les **granularit√©s** de nos microfronts ?
  (une ent√™te peut √™tre un microfront, compos√© d'une zone d'authentification qui peut aussi √™tre un microfront, compos√© d'un bouton chart√© qui peut √©galement √™tre un microfront)
- Comment le shell devine **quels √©l√©ments afficher** ? Si le shell utilise le **path de l'URL** pour router vers tel ou tel √©l√©ment, alors comment faire cohabiter le routeur du shell et le "sous-routeur" d'un √©l√©ment (SPA) ?
- Est-ce qu'il est possible de m√©langer des technologies, ou √† minima plusieurs versions d'une m√™me technologie ?  

Les contraintes d'un microfront web :

- Les librairies/frameworks doivent pouvoir **cohabiter**. Et ce m√™me s'il n'y a qu'un seul microfront affich√© √† un instant T, car les autres microfronts affich√©s pr√©c√©demment peuvent rester en m√©moire.  
  Pour √©viter des "collisions" de technologies, nous favorisons donc des frameworks/librairies qui ne sont pas intrusives et dont l'int√©gration est d√©limit√©e/scop√©e. C'est ce que nous pouvons retrouver sur les librairies comme _Vue, React, Svelte, WebComponent, etc.  
  Gr√¢ce √† cela, il est possible d'avoir **N technologies diff√©rentes en N versions diff√©rentes sur un m√™me site**. La multiplication des technologies peut d√©grader les performances (m√©moires), il faut donc avoir une ma√Ætrise sur les √©l√©ments charg√©s, et d√©charg√©s.
  :::info
  Le moteur d'Angular (Zone) est intrusif : il alt√®re les interactions entre l'application web et le navigateur. Nous ne favorisons donc pas cette technologie dans le cadre d'une architecture MFE. √Ä noter tout de m√™me que des [d√©veloppements sont en cours](https://angular.io/guide/signals) pour supprimer cet aspect intrusif.
  :::
- Du fait du chargement √† la vol√©e des √©l√©ments, il est important d'avoir √©galement la maitrise des d√©lais de premi√®re restitution et de premi√®re interaction. **L'architecture microfront ne doit pas impacter l'exp√©rience utilisateur**.
- ...

## Microfront - Basique

L'approche la plus basique d'une application microfront est d'afficher une page **statique** en fonction de l'URL, le tout g√©r√© enti√®rement c√¥t√© navigateur (CSR).  
Ici, notre application microfronts est bas√©e sur un seul niveau de routage.  
  
L'utilisateur arrive sur le site :
<BlurFlow>
  <BlurFlowStep unblurred={true}>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell  
      </div>
    </BrowserWindow>
    Le shell d'initialise. La page est enti√®rement vide, cela ne dure que quelques millisecondes et n'impacte pas l'utilisateur.  
    √Ä ce moment l√†, il sait :
    - quel √©l√©ment charger et afficher en fonction de la navigation de l'utilisateur (`/` = page d'accueil, `/contact`= formulaire de contact).
    - s'il faut afficher une mise en page (layout).
    Notre shell va f√©d√©rer les √©l√©ments microfronts √† travers sa capacit√© de **routage**. C'est sur ce point qu'une grosse partie de la complexit√© de notre shell se situe.  
    <div class="flow-action"><button onClick={unblurNextStep}>üëâ Faire un bon de quelques millisecondes dans le futur</button></div>
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">‚á©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : Ent√™te & menu  
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    S'il n'est pas directement inclu dans le shell, le layout doit √™tre charg√© et affich√©. Ce qui peut √† nouveau prendre quelques millisecondes.
    <div class="flow-action"><button onClick={unblurNextStep}>üëâ Faire un nouveau bon de quelques millisecondes dans le futur</button></div>
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">‚á©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : Ent√™te & menu
          <div className="box--inner">
            √âl√©ment microfront : **Page d'accueil**  
            <div class="flow-action"><button onClick={unblurNextStep}>üëâ Aller sur la page de contact</button></div>
          </div>
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    Le shell d√©tecte que l'utilisateur se trouve sur la page `/`, puis charge et affiche l'√©l√©ment microfront correspondant.  
    La page d'accueil contient un lien vers la page de contact `/contact`.
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">‚á©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/contact</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : Ent√™te & menu
          <div className="box--inner">
            √âl√©ment microfront : **Formulaire de contact**  
            <div class="flow-action"><button onClick={unblurNextStep}>üëâ Page d'accueil</button></div>
          </div>
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    Le shell d√©tecte que l'utilisateur se trouve sur la page de contact `/contact`, puis charge et affiche l'√©l√©ment microfront correspondant.  
    L'√©l√©ment page d'accueil est d√©charg√© **au mieux**, car certains composants peuvent rester r√©f√©renc√©s en m√©moire. Les d√©r√©f√©rencer proprement peut parfois √™tre complexe.
    Finalement, l'utilisateur veut revenir √† la plage pr√©c√©dente.
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">‚á©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : Ent√™te & menu
          <div className="box--inner">
            √âl√©ment microfront : **Page d'accueil**  
          </div>
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    Le shell d√©tecte que l'utilisateur se trouve sur la page `/`, et (re)charge puis affiche l'√©l√©ment microfront correspondant.  
    L'utilisateur a affich√© 3 composants diff√©rents,: le shell, la page d'accueil, le formulaire de contact.
    L'exp√©rience utilisateur ne doit pas √™tre impact√©e par une architecture microfront. 
  </BlurFlowStep>
</BlurFlow>


## Microfront - Double niveau de routage

Mettre √† disposition des parcours utilisateurs peut paraitre complexe voir impossible avec un seul niveau de routage. Il faudrait ainsi un √©l√©ment microfront par page.  
Le plus courant est donc de retrouver un double niveau de routage :
- Un routage de premier niveau g√©r√© par le shell.
- Au besoin, un routage de second niveau g√©r√© par l'√©l√©ment microfront (type SPA). 
  
Admettons dans notre cas, le formulaire de contact se d√©compose en 2 √©tapes : page de saisie, puis page de confirmation.

<BlurFlow>
  <BlurFlowStep unblurred={true}>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell  
      </div>
    </BrowserWindow>
    Comme dans notre cas pr√©c√©dent, le shell s'initialise.
    Sa configuration de routage est n√©amoins plus souple :
    - Le chemin `/` correspond exactement √† la page d'accueil (identique routage simple).
    - Les chemins **commen√ßant par** `/contact/` correspondent formulaire de contact.  
    Pour certains parcours, le routeur du shell √† la capacit√© de se fier au d√©but de l'URL, et non plus √† l'exactitude de l'URL (`√©gal √†` vs. `commen√ßant par`).  
    Tant que le d√©but du chemin ne bouge pas vers un autre chemin connu par le routeur de premier niveau, celui-ci ne fera rien et fera confiance au routeur pr√©sent dans l'√©l√©ment microfront.  
    <div class="flow-action"><button onClick={unblurNextStep}>üëâ Faire un bon de quelques millisecondes dans le futur</button></div>
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">‚á©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : Ent√™te & menu  
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    Le shell charge et affiche le layout.
    <div class="arrow">‚á©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : Ent√™te & menu
          <div className="box--inner">
            √âl√©ment microfront : **Page d'accueil**  
            <div class="flow-action"><button onClick={unblurNextStep}>üëâ Aller sur le parcours de contact</button></div>
          </div>
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    L'utilisateur chercher √† aller sur le parcours de contact.  
    L'important se situe juste apr√®s ! üëá
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">‚á©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/contact/saisie</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : Ent√™te & menu
          <div className="box--inner">
            √âl√©ment microfront : **Formulaire de contact / Page de saisie**  
            <div class="flow-action"><button onClick={unblurNextStep}>üëâ Aller √† la page de confirmation</button></div>
          </div>
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    Le shell d√©tecte que l'utilisateur a bascul√© sur un chemin commen√ßant par `/contact`. Il charge et affiche l'√©l√©ment microfront correspondant.  
    Cette fois, l'utilisateur veut confirmer.  
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">‚á©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/contact/confirmation</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : Ent√™te & menu
          <div className="box--inner">
            √âl√©ment microfront : **Formulaire de contact / Page de confirmation**  
            <div class="flow-action"><button onClick={unblurNextStep}>üëâ Page d'accueil</button></div>
          </div>
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    Le shell a vu le changement de chemin (`/contact/saisie` ‚ûú `/contact/confirmation`), mais il sait qu'il s'agit d'un parcours et **ne fait rien**, il sait que l'**√©l√©ment microfront est √† la man≈ìuvre**.  
    L'utilisateur veut retourner sur la page d'accueil.  
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">‚á©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : Ent√™te & menu
          <div className="box--inner">
            √âl√©ment microfront : **Page d'accueil**  
          </div>
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    Le shell d√©tecte que l'utilisateur √† bascul√© sur le chemin `/`, l'utilisateur est sorti du parcours de `/contact`.  
    Le shell (re)charge puis affiche l'√©l√©ment microfront correspondant.  
  </BlurFlowStep>
</BlurFlow>
  
Ce type de routage apporte une contrainte : les routes de second niveau (ici `/contact/saisie` et `/contact/confirmation`) doivent avoir un discriminant pour ne pas perturber le routeur de premier niveau.  
Par exemple dans notre cas, si la page de confirmation se trouvait sur le chemin `/confirmation` (au lieu de `/contact/confirmation`) et que ce chemin n'√©tait pas correctement connu par le shell, ce dernier aurait pu reprendre la main sur le routage et rompre le parcour de l'utilisateur. Maintenir un d√©but du chemin (ici `/contact/`) est une solution simple et efficace pour √©viter les collisions entre les routeurs de premier et second niveau.
