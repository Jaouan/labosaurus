import { Sandpack } from '@codesandbox/sandpack-react';
import { BlurFlow, BlurFlowStep, BrowserWindow, unblurNextStep } from '@jaouan/labosaurus';

# 1. La thÃ©orie des MFE

## Principe

ğŸ‘‰ Le principe de microfront (ou MicroFrontEnd ou MFE) consiste Ã  charger/dÃ©charger Ã  la demande, au sein d'une mÃªme application, des Ã©lÃ©ments IHM qui ont leur propre cycle de vie.
  
Nous retrouvons gÃ©nÃ©ralement plusieurs modules :

- un **shell** : la **coquille vide** qui contient le coeur logique. C'est **le point d'entrÃ©e**, qui va gÃ©rer le chargement et l'affichage des Ã©lÃ©ments microfront. Il connait, ou du moins sait oÃ¹ aller chercher, la liste des Ã©lÃ©ments microfronts disponibles.
- un **layout** : la **mise en page** qui donne les indications au shell sur oÃ¹ disposer les microfronts Ã  l'Ã©cran. Parfois, le layout est intÃ©grÃ© directement dans le shell.
- les **Ã©lÃ©ments microfronts** : les contenus/parcours/composants Ã  afficher.

Il peut y avoir plusieurs spÃ©cificitÃ©s dans l'approche :

- Est-ce qu'il y a **1 ou N composants affichÃ©s** en mÃªme temps sur un Ã©cran ?
- Est-ce que les composants **partagent des donnÃ©es** entre eux ?
- Est-ce qu'un composant peut Ãªtre **intÃ©grÃ© de plusieurs maniÃ¨res** diffÃ©rentes (en tant que page complÃ¨te, et en tant que "morceau" d'une autre page) ?
- Quelles sont les **granularitÃ©s** de nos microfronts ?
  (une entÃªte peut Ãªtre un microfront, composÃ© d'une zone d'authentification qui peut aussi Ãªtre un microfront, composÃ© d'un bouton chartÃ© qui peut Ã©galement Ãªtre un microfront)
- Comment le shell devine **quels Ã©lÃ©ments afficher** ? Si le shell utilise le **path de l'URL** pour router vers tel ou tel Ã©lÃ©ment, alors comment faire cohabiter le routeur du shell et le "sous-routeur" d'un Ã©lÃ©ment (SPA) ?
- Est-ce qu'il est possible de mÃ©langer des technologies, ou Ã  minima plusieurs versions d'une mÃªme technologie ?  

Les contraintes d'un microfront web :

- Les librairies/frameworks doivent pouvoir **cohabiter**. Et ce mÃªme s'il n'y a qu'un seul microfront affichÃ© Ã  un instant T, car les autres microfronts affichÃ©s prÃ©cÃ©demment peuvent rester en mÃ©moire.  
  Pour Ã©viter des "collisions" de technologies, nous favorisons donc des frameworks/librairies qui ne sont pas intrusives et dont l'intÃ©gration est dÃ©limitÃ©e/scopÃ©e. C'est ce que nous pouvons retrouver sur les librairies comme _Vue, React, Svelte, WebComponent, etc.  
  GrÃ¢ce Ã  cela, il est possible d'avoir **N technologies diffÃ©rentes en N versions diffÃ©rentes sur un mÃªme site**. La multiplication des technologies peut dÃ©grader les performances (mÃ©moires), il faut donc avoir une maÃ®trise sur les Ã©lÃ©ments chargÃ©s, et dÃ©chargÃ©s.
  :::info
  Le moteur d'Angular (Zone) est intrusif : il altÃ¨re les interactions entre l'application web et le navigateur. Nous ne favorisons donc pas cette technologie dans le cadre d'une architecture MFE. Ã€ noter tout de mÃªme que des [dÃ©veloppements sont en cours](https://angular.io/guide/signals) pour supprimer cet aspect intrusif.
  :::
- Du fait du chargement Ã  la volÃ©e des Ã©lÃ©ments, il est important d'avoir Ã©galement la maitrise des dÃ©lais de premiÃ¨re restitution et de premiÃ¨re interaction. **L'architecture microfront ne doit pas impacter l'expÃ©rience utilisateur**.
- ...

## Microfront - Basique

L'approche la plus basique d'une application microfront est d'afficher une page **statique** en fonction de l'URL, le tout gÃ©rÃ© entiÃ¨rement cÃ´tÃ© navigateur (CSR).  
Ici, notre application microfronts est basÃ©e sur un seul niveau de routage.  
  
L'utilisateur arrive sur le site :
<BlurFlow>
  <BlurFlowStep unblurred={true}>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell  
      </div>
    </BrowserWindow>
    Le shell d'initialise. La page est entiÃ¨rement vide, cela ne dure que quelques millisecondes et n'impacte pas l'utilisateur.  
    Ã€ ce moment lÃ , il sait :
    - quel Ã©lÃ©ment charger et afficher en fonction de la navigation de l'utilisateur (`/` = page d'accueil, `/contact`= formulaire de contact).
    - s'il faut afficher une mise en page (layout).
    Notre shell va fÃ©dÃ©rer les Ã©lÃ©ments microfronts Ã  travers sa capacitÃ© de **routage**. C'est sur ce point qu'une grosse partie de la complexitÃ© de notre shell se situe.  
    <div class="flow-action"><button onClick={unblurNextStep}>ğŸ‘‰ Faire un bon de quelques millisecondes dans le futur</button></div>
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">â‡©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : EntÃªte & menu  
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    S'il n'est pas directement inclu dans le shell, le layout doit Ãªtre chargÃ© et affichÃ©. Ce qui peut Ã  nouveau prendre quelques millisecondes.
    <div class="flow-action"><button onClick={unblurNextStep}>ğŸ‘‰ Faire un nouveau bon de quelques millisecondes dans le futur</button></div>
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">â‡©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : EntÃªte & menu
          <div className="box--inner">
            Ã‰lÃ©ment microfront : **Page d'accueil**  
            <div class="flow-action"><button onClick={unblurNextStep}>ğŸ‘‰ Aller sur la page de contact</button></div>
          </div>
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    Le shell dÃ©tecte que l'utilisateur se trouve sur la page `/`, puis charge et affiche l'Ã©lÃ©ment microfront correspondant.  
    La page d'accueil contient un lien vers la page de contact `/contact`.
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">â‡©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/contact</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : EntÃªte & menu
          <div className="box--inner">
            Ã‰lÃ©ment microfront : **Formulaire de contact**  
            <div class="flow-action"><button onClick={unblurNextStep}>ğŸ‘‰ Page d'accueil</button></div>
          </div>
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    Le shell dÃ©tecte que l'utilisateur se trouve sur la page de contact `/contact`, puis charge et affiche l'Ã©lÃ©ment microfront correspondant.  
    L'Ã©lÃ©ment page d'accueil est dÃ©chargÃ© **au mieux**, car certains composants peuvent rester rÃ©fÃ©rencÃ©s en mÃ©moire. Les dÃ©rÃ©fÃ©rencer proprement peut parfois Ãªtre complexe.
    Finalement, l'utilisateur veut revenir Ã  la plage prÃ©cÃ©dente.
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">â‡©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : EntÃªte & menu
          <div className="box--inner">
            Ã‰lÃ©ment microfront : **Page d'accueil**  
          </div>
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    Le shell dÃ©tecte que l'utilisateur se trouve sur la page `/`, et (re)charge puis affiche l'Ã©lÃ©ment microfront correspondant.  
    L'utilisateur a affichÃ© 3 composants diffÃ©rents,: le shell, la page d'accueil, le formulaire de contact.
    L'expÃ©rience utilisateur ne doit pas Ãªtre impactÃ©e par une architecture microfront. 
  </BlurFlowStep>
</BlurFlow>


## Microfront - Double niveau de routage

Mettre Ã  disposition des parcours utilisateurs peut paraitre complexe voir impossible avec un seul niveau de routage. Il faudrait ainsi un Ã©lÃ©ment microfront par page.  
Le plus courant est donc de retrouver un double niveau de routage :
- Un routage de premier niveau gÃ©rÃ© par le shell.
- Au besoin, un routage de second niveau gÃ©rÃ© par l'Ã©lÃ©ment microfront (type SPA). 
  
Admettons dans notre cas, le formulaire de contact se dÃ©compose en 2 Ã©tapes : page de saisie, puis page de confirmation.

<BlurFlow>
  <BlurFlowStep unblurred={true}>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell  
      </div>
    </BrowserWindow>
    Comme dans notre cas prÃ©cÃ©dent, le shell s'initialise.
    Sa configuration de routage est nÃ©amoins plus souple :
    - Le chemin `/` correspond exactement Ã  la page d'accueil (identique routage simple).
    - Les chemins **commenÃ§ant par** `/contact/` correspondent formulaire de contact.  
    Pour certains parcours, le routeur du shell Ã  la capacitÃ© de se fier au dÃ©but de l'URL, et non plus Ã  l'exactitude de l'URL (`Ã©gal Ã ` vs. `commenÃ§ant par`).  
    Tant que le dÃ©but du chemin ne bouge pas vers un autre chemin connu par le routeur de premier niveau, celui-ci ne fera rien et fera confiance au routeur prÃ©sent dans l'Ã©lÃ©ment microfront.  
    <div class="flow-action"><button onClick={unblurNextStep}>ğŸ‘‰ Faire un bon de quelques millisecondes dans le futur</button></div>
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">â‡©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : EntÃªte & menu  
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    Le shell charge et affiche le layout.
    <div class="arrow">â‡©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : EntÃªte & menu
          <div className="box--inner">
            Ã‰lÃ©ment microfront : **Page d'accueil**  
            <div class="flow-action"><button onClick={unblurNextStep}>ğŸ‘‰ Aller sur le parcours de contact</button></div>
          </div>
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    L'utilisateur chercher Ã  aller sur le parcours de contact.  
    L'important se situe juste aprÃ¨s ! ğŸ‘‡
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">â‡©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/contact/saisie</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : EntÃªte & menu
          <div className="box--inner">
            Ã‰lÃ©ment microfront : **Formulaire de contact / Page de saisie**  
            <div class="flow-action"><button onClick={unblurNextStep}>ğŸ‘‰ Aller Ã  la page de confirmation</button></div>
          </div>
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    Le shell dÃ©tecte que l'utilisateur a basculÃ© sur un chemin commenÃ§ant par `/contact`. Il charge et affiche l'Ã©lÃ©ment microfront correspondant.  
    Cette fois, l'utilisateur veut confirmer.  
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">â‡©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/contact/confirmation</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : EntÃªte & menu
          <div className="box--inner">
            Ã‰lÃ©ment microfront : **Formulaire de contact / Page de confirmation**  
            <div class="flow-action"><button onClick={unblurNextStep}>ğŸ‘‰ Page d'accueil</button></div>
          </div>
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    Le shell a vu le changement de chemin (`/contact/saisie` âœ `/contact/confirmation`), mais il sait qu'il s'agit d'un parcours et **ne fait rien**, il sait que l'**Ã©lÃ©ment microfront est Ã  la manÅ“uvre**.  
    L'utilisateur veut retourner sur la page d'accueil.  
  </BlurFlowStep>
  <BlurFlowStep>
    <div class="arrow">â‡©</div>
    <BrowserWindow url={`https://mon-app<span class="browserwindow-url--highlight">/</span>`}>
      <div className="box">
        Shell
        <div className="box--inner">
          Layout : EntÃªte & menu
          <div className="box--inner">
            Ã‰lÃ©ment microfront : **Page d'accueil**  
          </div>
          Pied de page
        </div>
      </div>
    </BrowserWindow>
    Le shell dÃ©tecte que l'utilisateur Ã  basculÃ© sur le chemin `/`, l'utilisateur est sorti du parcours de `/contact`.  
    Le shell (re)charge puis affiche l'Ã©lÃ©ment microfront correspondant.  
  </BlurFlowStep>
</BlurFlow>
  
Ce type de routage apporte une contrainte : les routes de second niveau (ici `/contact/saisie` et `/contact/confirmation`) doivent avoir un discriminant pour ne pas perturber le routeur de premier niveau.  
Par exemple dans notre cas, si la page de confirmation se trouvait sur le chemin `/confirmation` (au lieu de `/contact/confirmation`) et que ce chemin n'Ã©tait pas correctement connu par le shell, ce dernier aurait pu reprendre la main sur le routage et rompre le parcour de l'utilisateur. Maintenir un dÃ©but du chemin (ici `/contact/`) est une solution simple et efficace pour Ã©viter les collisions entre les routeurs de premier et second niveau.
